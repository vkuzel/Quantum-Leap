package cz.quantumleap.core.data.entity;

import cz.quantumleap.core.data.mapper.MapperUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Table;
import org.jooq.impl.DSL;

import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EntityIdentifier<TABLE extends Table<? extends Record>> {

    private static final Pattern ENTITY_IDENTIFIER_PATTERN = Pattern.compile("^([^.]+)\\.([^#]+)(#.+)?$");

    private final TABLE table;
    private final String qualifier;

    public EntityIdentifier(TABLE table, String qualifier) {
        Validate.notNull(table);
        this.table = table;
        this.qualifier = qualifier;
    }

    public static <TABLE extends Table<? extends Record>> EntityIdentifier<TABLE> forTable(TABLE table) {
        return forTableWithQualifier(table, null);
    }

    public static <TABLE extends Table<? extends Record>> EntityIdentifier<TABLE> forTableWithQualifier(TABLE table, String qualifier) {
        return new EntityIdentifier<>(table, qualifier);
    }

    public TABLE getTable() {
        return table;
    }

    public String getQualifier() {
        return qualifier;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EntityIdentifier<?> that = (EntityIdentifier<?>) o;
        // Generated table does not have fully qualified name even though the
        // Table object holds a schema name. So we will compare schema name and
        // unqualified table name separately.
        return Objects.equals(table.getSchema(), that.getTable().getSchema()) &&
                Objects.equals(table.getUnqualifiedName(), that.table.getUnqualifiedName()) &&
                Objects.equals(qualifier, that.qualifier);
    }

    @Override
    public int hashCode() {
        return Objects.hash(table.getSchema().getName(), table.getUnqualifiedName(), qualifier);
    }

    /**
     * Outputs this identifier as a string which can be parsed by parse method
     * to recreate the object.
     */
    @Override
    public String toString() {
        String value = MapperUtils.resolveDatabaseTableNameWithSchema(table);
        if (StringUtils.isNotBlank(qualifier)) {
            value += '#' + qualifier;
        }
        return value;
    }

    /**
     * Parse entity identifier from a string generated by toString method.
     */
    public static EntityIdentifier<?> parse(CharSequence text) {
        Matcher matcher = ENTITY_IDENTIFIER_PATTERN.matcher(text);

        if (!matcher.matches()) {
            throw new IllegalArgumentException("Cannot parse " + text + " to EntityIdentifier!");
        }

        String schemaName = matcher.group(1);
        String tableName = matcher.group(2);
        String qualifier = matcher.group(3) != null ? matcher.group(3).substring(1) : null;

        Name name = DSL.name(schemaName, tableName);
        Table<?> table = DSL.table(name);
        return EntityIdentifier.forTableWithQualifier(table, qualifier);
    }
}
