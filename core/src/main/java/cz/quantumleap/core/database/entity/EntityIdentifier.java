package cz.quantumleap.core.database.entity;

import org.jooq.Record;
import org.jooq.Table;
import org.jooq.impl.DSL;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static cz.quantumleap.core.database.query.QueryUtils.resolveDatabaseTableNameWithSchema;
import static cz.quantumleap.core.utils.Strings.isNotBlank;
import static java.util.Objects.requireNonNull;

public class EntityIdentifier<TABLE extends Table<? extends Record>> {

    private final TABLE table;
    private final String qualifier;

    public EntityIdentifier(TABLE table, String qualifier) {
        requireNonNull(table);
        this.table = table;
        this.qualifier = qualifier;
    }

    public static <TABLE extends Table<? extends Record>> EntityIdentifier<TABLE> forTable(TABLE table) {
        return forTableWithQualifier(table, null);
    }

    public static <TABLE extends Table<? extends Record>> EntityIdentifier<TABLE> forTableWithQualifier(TABLE table, String qualifier) {
        return new EntityIdentifier<>(table, qualifier);
    }

    public TABLE getTable() {
        return table;
    }

    public String getQualifier() {
        return qualifier;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        var that = (EntityIdentifier<?>) o;
        // Generated table does not have fully qualified name even though the
        // Table object holds a schema name. So we will compare schema name and
        // unqualified table name separately.
        return Objects.equals(table.getSchema(), that.getTable().getSchema()) &&
                Objects.equals(table.getUnqualifiedName(), that.table.getUnqualifiedName()) &&
                Objects.equals(qualifier, that.qualifier);
    }

    @Override
    public int hashCode() {
        var schemaName = table.getSchema() != null ? table.getSchema().getName() : null;
        return Objects.hash(schemaName, table.getUnqualifiedName(), qualifier);
    }

    /**
     * Outputs this identifier as a string which can be parsed by parse method
     * to recreate the object.
     */
    @Override
    public String toString() {
        var value = resolveDatabaseTableNameWithSchema(table);
        if (isNotBlank(qualifier)) {
            value += '#' + qualifier;
        }
        return value;
    }

    /**
     * Parse entity identifier from a string generated by the toString method
     * of this class, or by the jOOQ.Table.toString() method.
     */
    public static EntityIdentifier<?> parse(String code) {
        List<String> fragments = new ArrayList<>(3);
        var len = code.length();
        var fragmentStart = -1;
        var escaped = false;

        for (var i = 0; i < code.length(); i++) {
            var chr = code.charAt(i);
            if ((chr == '.' || chr == '#' || chr == '"') && !escaped && fragmentStart > -1) {
                fragments.add(code.substring(fragmentStart, i));
                fragmentStart = -1;
            } else if (chr != '.' && chr != '#' && chr != '"' && !escaped && fragmentStart == -1) {
                fragmentStart = i;
            } else if (chr == '\\' && !escaped) {
                escaped = true;
            } else if (escaped) {
                escaped = false;
            }
        }

        if (fragmentStart > -1 && fragmentStart < len) {
            fragments.add(code.substring(fragmentStart, len));
        }

        if (fragments.size() < 2 || fragments.size() > 3) {
            throw new IllegalArgumentException("Cannot parse " + code + " to EntityIdentifier!");
        }

        var schemaName = fragments.get(0);
        var tableName = fragments.get(1);
        var qualifier = fragments.size() > 2 ? fragments.get(2) : null;

        var name = DSL.name(schemaName, tableName);
        Table<?> table = DSL.table(name);
        return EntityIdentifier.forTableWithQualifier(table, qualifier);
    }
}
